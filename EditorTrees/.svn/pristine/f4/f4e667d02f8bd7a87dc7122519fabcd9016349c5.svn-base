package editortrees;

import editortrees.EditTree.Container;

// A node in a height-balanced binary tree with rank.
// Except for the NULL_NODE (if you choose to use one), one node cannot
// belong to two different trees.

public class Node {

	enum Code {
		SAME, LEFT, RIGHT;
		// Used in the displayer and debug string
		public String toString() {
			switch (this) {
			case LEFT:
				return "/";
			case SAME:
				return "=";
			case RIGHT:
				return "\\";
			default:
				throw new IllegalStateException();
			}
		}
	}
	char element;
	Node left, right; // subtrees
	int rank; // inorder position of this node within its own subtree.
	Code balance;

	private int leftHeight;
	private int rightHeight;
//	private char balCode; // balCode stores the way the tree balances ('/', '=', or '\\')
//	private Node NULL_NODE;
	public Container c;
	
	/*
	 * Constructor that makes a NULL_NODE
	 */
	public Node() {
		this.element = ' ';
		this.left = null;
		this.right = null;
		this.leftHeight = 0;
		this.rightHeight = 0;
		this.rank = 0;
		this.balance = Code.SAME;
	}

	/*
	 * Constructor that makes a node with element ch
	 */
	public Node(char ch, Container c) {
		this.element = ch;
		this.c = c;
		this.left = c.NULL_NODE;
		this.right = c.NULL_NODE;
		this.leftHeight = 0;
		this.rightHeight = 0;
		this.rank = 0;
		this.balance = Code.SAME;
	}

	/*
	 * Constructs a node from a node
	 */
	public Node(Node node, Container c) {
		this.element = node.element;
		this.left = new Node(node.left, c);
		this.right = new Node(node.right, c);
		this.leftHeight = node.leftHeight;
		this.rightHeight = node.rightHeight;
		this.c = c;
		this.setBalanceCode();
	}

	/*
	 * Deletes a node from the tree at position pos
	 */
	public void delete(int pos) {
		if (pos > this.rank + 1 && this.right == c.NULL_NODE) {
			throw new IndexOutOfBoundsException();
		}
		if (pos < this.rank) {
			this.rank--;

			if (this.left == c.NULL_NODE) {
				throw new IndexOutOfBoundsException();
			}
			this.left.delete(pos);
			this.left = c.returned;
			if (this.left == c.NULL_NODE) {
				this.leftHeight = 0;
				this.rank = 0;
			} else {
				this.leftHeight = Math.max(this.left.leftHeight, this.left.rightHeight) + 1;
			}

			this.setBalanceCode();
			if (Math.abs(this.leftHeight - this.rightHeight) > 1) {
				if ((this.leftHeight < this.rightHeight) && (this.right.leftHeight < this.right.rightHeight)) {
					c.returned = this.singleLeftRot();
					return;
				} else if ((this.leftHeight < this.rightHeight) && (this.right.leftHeight > this.right.rightHeight)) {
					c.returned = this.doubleLeftRot();
					return;
				}
			}

			c.returned = this;

		} else if (pos > this.rank) {
			if (this.right == c.NULL_NODE) {
				throw new IndexOutOfBoundsException();
			}
			this.right.delete(pos - (this.rank + 1));
			this.right = c.returned;
			if (this.right == c.NULL_NODE) {
				this.rightHeight = 0;
			} else {
				this.rightHeight = Math.max(this.right.leftHeight, this.right.rightHeight) + 1;
			}
			this.setBalanceCode();
			if (Math.abs(this.leftHeight - this.rightHeight) > 1) {
				if ((this.leftHeight > this.rightHeight) && (this.left.leftHeight > this.left.rightHeight)) {
					c.returned = this.singleRightRot();
					return;
				} else if ((this.leftHeight > this.rightHeight) && (this.left.leftHeight < this.left.rightHeight)) {
					c.returned = this.doubleRightRot();
					return;
				} else {
					this.setBalanceCode();
				}
			}
			c.returned = this;
		} else {
			c.deleted = this;
			if (this.right == c.NULL_NODE && this.left == c.NULL_NODE) {
				c.returned = c.NULL_NODE;
			} else if (this.right != c.NULL_NODE) {
				if (this.right.left == c.NULL_NODE) {
					this.right.left = this.left;
					this.right.rank = this.rank;
					this.right.leftHeight = this.leftHeight;
					this.right.setBalanceCode();
					if (Math.abs(this.right.leftHeight - this.right.rightHeight) > 1) {
						if ((this.right.leftHeight > this.right.rightHeight) && (this.right.left.leftHeight > this.right.left.rightHeight)) {
							c.returned = this.right.singleRightRot();
							return;
						} else if ((this.right.leftHeight > this.right.rightHeight) && (this.right.left.leftHeight < this.right.left.rightHeight)) {
							c.returned = this.right.doubleRightRot();
							return;
						} else {
							this.setBalanceCode();
						}
					}
					c.returned = this.right;
				} else {
					Node temp = this.right.findNode();
					// EditorTreeNode tempRight = temp.right;
					temp.left = this.left;
					temp.right = this.right;
					// temp.right.getNext().left = tempRight;
					temp.rightHeight = Math.max(this.right.leftHeight, this.right.rightHeight) + 1;
					temp.rank = this.rank;
					this.right.left = c.NULL_NODE;
					temp.right.leftHeight = Math.max(temp.right.left.leftHeight, temp.right.left.rightHeight) + 1;
					
					temp.setBalanceCode();
					temp.right.setBalanceCode();
					c.returned = temp;
				}
			} else if (this.left != c.NULL_NODE) {
				c.returned = this.left;
			}
		}
		this.setBalanceCode();

	}

	public Node findNode() {
		if (this.rank == 0) {
			return this;
		}
		return this.left.findNode();

	}

	private Node getNext() {
		Node node = this;
		Node prevnode = node;
		while (node.left != c.NULL_NODE) {
			prevnode = node;
			node = node.left;
		}
		prevnode.left = node.right;
		prevnode.leftHeight = Math.max(this.left.leftHeight, this.left.rightHeight) + 1;
		prevnode.setBalanceCode();
		return node;
	}

	/*
	 * Copies EditorTree e, passing in e's NULL_NODE and its root n.
	 */
	public void copyTree(Node n, Node nNull) {
		if (n != nNull) {
			if (n.left != nNull) {
				this.left = new Node(n.left.element, c);
				this.left.copyTree(n.left, nNull);
				this.leftHeight = Math.max(this.left.leftHeight, this.left.rightHeight) + 1;
			}

			if (n.right != nNull) {
				this.right = new Node(n.right.element, c);
				this.right.copyTree(n.right, nNull);
				this.rightHeight = Math.max(this.right.leftHeight, this.right.rightHeight) + 1;
			}
			this.setBalanceCode();
		}
	}

	/*
	 * Returns the size of the tree recursively and efficiently
	 */
	public int getSize() {
		if (this.element == ' ') {
			return 0;
		}
		return this.rank + this.right.getSize() + 1;
	}

	/*
	 * Adds a char (ch) to a specific position (pos)
	 */
	public Node add(char ch, int pos) {
		if (pos > this.rank + 1 && this.right == c.NULL_NODE) {
			throw new IndexOutOfBoundsException();
		}
		if (pos <= this.rank) {
			this.rank++;

			if (this.left == c.NULL_NODE) {
				this.left = new Node(ch, c);
				this.leftHeight = 1;
				this.setBalanceCode();
			} else {
				this.left = this.left.add(ch, pos);
				this.leftHeight = Math.max(this.left.leftHeight, this.left.rightHeight) + 1;
				if (Math.abs(this.leftHeight - this.rightHeight) > 1) {
					if ((this.leftHeight > this.rightHeight) && (this.left.leftHeight > this.left.rightHeight)) {
						return this.singleRightRot();
					} else if ((this.leftHeight > this.rightHeight) && (this.left.leftHeight < this.left.rightHeight)) {
						return this.doubleRightRot();
					} else {
						this.setBalanceCode();
					}
				}
			}

		} else if (pos > this.rank) {
			if (this.right == c.NULL_NODE) {
				this.right = new Node(ch, c);
				this.rightHeight = 1;
			} else {
				this.right = this.right.add(ch, pos - (this.rank + 1));
				this.rightHeight = Math.max(this.right.leftHeight, this.right.rightHeight) + 1;
				if (Math.abs(this.leftHeight - this.rightHeight) > 1) {
					if ((this.leftHeight < this.rightHeight) && (this.right.leftHeight < this.right.rightHeight)) {
						return this.singleLeftRot();
					} else if ((this.leftHeight < this.rightHeight)
							&& (this.right.leftHeight > this.right.rightHeight)) {
						return this.doubleLeftRot();
					}
				}
			}
		}
		this.setBalanceCode();
		return this;
	}

	/*
	 * Adds a char to the rightmost position on the tree
	 */
	public Node add(char ch) {
		if (this.right == c.NULL_NODE) {
			this.rightHeight = 1;
			this.right = new Node(ch, c);
			this.setBalanceCode();
		} else {
			this.right = this.right.add(ch);
			this.rightHeight = Math.max(this.right.leftHeight, this.right.rightHeight) + 1;
			if (Math.abs(this.leftHeight - this.rightHeight) > 1) {
				if ((this.leftHeight < this.rightHeight) && (this.right.leftHeight < this.right.rightHeight)) {
					return this.singleLeftRot();
				} else if ((this.leftHeight < this.rightHeight) && (this.right.leftHeight > this.right.rightHeight)) {
					return this.doubleLeftRot();
				}
			}
		}
		this.setBalanceCode();
		return this;
	}

	/*
	 * Performs a double-right rotation by performing two single rotations
	 */
	private Node doubleRightRot() {
		this.left = this.left.singleLeftRot();
		return this.singleRightRot();
	}

	/*
	 * Performs a double-left rotation by performing two single rotations
	 */
	private Node doubleLeftRot() {
		this.right = this.right.singleRightRot();
		return this.singleLeftRot();
	}

	/*
	 * Performs a single-left rotation and increases the number of rotations
	 */
	private Node singleLeftRot() {
		Node orphaned = this.right.left;
		Node newtop = this.right;
		this.right.left = this;
		this.right.rank += this.rank + 1;
		this.rightHeight = this.rightHeight - (this.right.rightHeight + 1) + this.right.leftHeight;
		this.right.leftHeight = ((Math.max(this.right.leftHeight, this.leftHeight)) + 1);
		this.right.setBalanceCode();
		this.right = orphaned;
		this.setBalanceCode();
		c.num_rot++;
		return newtop;
	}

	/*
	 * Performs a single-right rotation and increases the number of rotations
	 */
	private Node singleRightRot() {
		Node orphaned = this.left.right;
		Node newtop = this.left;
		this.left.right = this;
		this.rank -= (this.left.rank + 1);
		this.leftHeight = this.leftHeight - (this.left.leftHeight + 1) + this.left.rightHeight;
		this.left.rightHeight = (Math.max(this.left.rightHeight, this.rightHeight)) + 1;
		this.left.setBalanceCode();
		this.left = orphaned;
		this.setBalanceCode();
		c.num_rot++;
		return newtop;
	}

	/*
	 * Resets the balance code of a node by comparing the left and right nodes'
	 * heights
	 */
	private void setBalanceCode() {
		if (this.leftHeight == this.rightHeight) {
			this.balance = Code.SAME;
		} else if (this.leftHeight > this.rightHeight) {
			this.balance = Code.LEFT;
		} else if (this.rightHeight > this.leftHeight) {
			this.balance = Code.RIGHT;
		}
	}

	/*
	 * Finds the node at position pos and returns the value at that position
	 */
	public char get(int pos) {
		if (this.element == ' ') {
			throw new IndexOutOfBoundsException();
		} else if (pos < this.rank) {
			return this.left.get(pos);
		} else if (pos > this.rank) {
			return this.right.get(pos - (this.rank + 1));
		}
		return this.element;
	}

	/*
	 * Prints each node's element out in an in-order traversal
	 */
	public String toString() {
		if (this.element == ' ') {
			return "";
		}
		return this.left.toString() + this.element + this.right.toString();
	}

	/*
	 * Prints each node's element, rank, and balance code in a pre-order
	 * traversal
	 */
	public String toDebugString() {
		if (this.element == ' ') {
			return "";
		}
		return "" + this.element + this.rank + this.balance + ", " + this.left.toDebugString()
				+ this.right.toDebugString();
	}

	/*
	 * Gets the height of a node by comparing its left and right nodes' heights
	 */
	public int height() {
		if (this.element == ' ') {
			return 0;
		}
		return (Math.max(this.leftHeight, this.rightHeight) + 1);
	}

}