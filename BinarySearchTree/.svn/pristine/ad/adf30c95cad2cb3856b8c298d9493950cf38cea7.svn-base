import java.util.ArrayList;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Stack;

//import BinarySearchTree.BinaryNode;

/**
 * 
 * Implementation of most of the Set interface operations using a Binary Search
 * Tree
 *
 * @author Matt Boutell and Olivia Penry.
 * @param <T>
 */

public class BinarySearchTree<T extends Comparable<? super T>> implements Iterable<T> {
	private BinaryNode root;
	private final BinaryNode NULL_NODE = new BinaryNode();

	public BinarySearchTree() {
		root = NULL_NODE;
	}

	void setRoot(BinaryNode n) {
		this.root = n;
	}

	public int size() {
		return root.sizeHelper();
	}

	public boolean containsNonBST(T val) {
		return this.root.containsNonBSTHelper(val);
	}

	public boolean insert(T i) {
		if (this.root == NULL_NODE) {
			BinaryNode n = new BinaryNode(i);
			setRoot(n);
			return true;
		} else if (i == null) {
			throw new IllegalArgumentException();
		} else {
			BooleanContainer bc = new BooleanContainer();
			bc = this.root.insert(i, bc);
			return bc.getBoolean();
		}
	}

	public Object height() {
		if (this.root == NULL_NODE) {
			return -1;
		}
		int max = 0;
		return this.root.heightHelper(max, 0);
	}

	public boolean isEmpty() {
		return this.root == NULL_NODE;
	}

	public Iterator<T> inefficientIterator() {
		return new ArrayListIterator();
	}

	public Iterator<T> preOrderIterator() {
		return new preOrderIterator();
	}

	public Iterator<T> iterator() {
		return new iterator();
	}

	public Object toArrayList() {
		ArrayListIterator arrIterator = new ArrayListIterator();
		return arrIterator.toArrayList();
	}

	public Object[] toArray() {
		ArrayListIterator arrIterator = new ArrayListIterator();
		return arrIterator.toArrayList().toArray();
	}

	public String toString() {
		ArrayListIterator list = new ArrayListIterator();
		return list.toArrayList().toString();
	}

	// ============ BINARY NODE CLASS ============ //

	class BinaryNode {
		private T data;
		private BinaryNode left;
		private BinaryNode right;

		public BinaryNode() {
			this.data = null;
			this.left = NULL_NODE;
			this.right = NULL_NODE;
		}

		public BinaryNode(T element) {
			this.data = element;
			this.left = NULL_NODE;
			this.right = NULL_NODE;
		}

		public T getData() {
			return this.data;
		}

		public BinaryNode getLeft() {
			return this.left;
		}

		public BinaryNode getRight() {
			return this.right;
		}

		public void setLeft(BinaryNode left) {
			this.left = left;
		}

		public void setRight(BinaryNode right) {
			this.right = right;
		}

		/* My methods */
		public BooleanContainer insert(T e, BooleanContainer bc) {
			if (this == NULL_NODE) {
				BinaryNode node = new BinaryNode(e);
				bc.setNode(node);
				return bc;
			} else if (e.compareTo(data) < 0) {
				bc = left.insert(e, bc);
				if (!bc.getBoolean()) {
					left = bc.node;
					bc.setBoolean(true);
				}
			} else if (e.compareTo(data) > 0) {
				bc = right.insert(e, bc);
				if (!bc.getBoolean()) {
					right = bc.node;
					bc.setBoolean(true);
				}
			}
			return bc;
		}

		public int heightHelper(int max, int tempMax) {
			if (this == NULL_NODE) {
				return max;
			}

			if (tempMax > max) {
				max = tempMax;
			}

			return Math.max(this.right.heightHelper(max, tempMax + 1), this.left.heightHelper(max, tempMax + 1));
		}

		public int sizeHelper() {
			if (this == NULL_NODE) {
				return 0;
			}
			return 1 + left.sizeHelper() + right.sizeHelper();
		}

		public boolean containsNonBSTHelper(T val) {
			if (this == NULL_NODE) {
				return false;
			}

			if (this.data.equals(val)) {
				return true;
			}

			return this.right.containsNonBSTHelper(val) || this.left.containsNonBSTHelper(val);
		}

		public void toArrayList(ArrayList<T> list) {
			if (this == NULL_NODE) {
				return;
			}
			left.toArrayList(list);
			list.add(data);
			right.toArrayList(list);
		}

		public void toArray(Object[] objects, int index) {
			if (this == NULL_NODE) {
				return;
			}
			left.toArray(objects, index);
			objects[index] = data;
			index = index + 1;
			right.toArray(objects, index);
		}

		public void toStack(Stack<BinaryNode> nodes) {
			if (this == NULL_NODE) {
				return;
			}
			this.right.toStack(nodes);
			this.left.toStack(nodes);
			nodes.push(this);
		}

		public void toStackInOrder(Stack<BinaryNode> nodes) {
			if (this == NULL_NODE) {
				return;
			}
			this.right.toStack(nodes);
			nodes.push(this);
			this.left.toStack(nodes);
		}

	}

	// ============ ITERATOR CLASSES ============ //

	/**
	 * ArrayList Iterator Class
	 */
	public class ArrayListIterator implements Iterator<T> {
		private ArrayList<T> list = new ArrayList<>();
		private int index;

		public ArrayListIterator() {
			index = 0;
			list = toArrayList();

		}

		@Override
		public boolean hasNext() {
			return index < list.size();
		}

		// next always returns the current value and moves to the next one
		@Override
		public T next() {
			if (!hasNext()) {
				throw new NoSuchElementException("No more next");
			}
			T temp = list.get(index);
			index++;
			return temp;
		}

		public ArrayList<T> toArrayList() {
			ArrayList<T> list = new ArrayList<T>();
			root.toArrayList(list);
			return list;
		}
	}

	/**
	 * preOrder lazy iterator class
	 */
	public class preOrderIterator implements Iterator<T> {
		Stack<BinaryNode> nodes;

		public preOrderIterator() {
			nodes = toStack();
		}

		@Override
		public boolean hasNext() {
			return !this.nodes.isEmpty();
		}

		@Override
		public T next() {
			if (!hasNext()) {
				throw new NoSuchElementException("No more next");
			}
			return this.nodes.pop().data;
		}

		public Stack<BinaryNode> toStack() {
			Stack<BinaryNode> nodes = new Stack<BinaryNode>();
			return nodes;
		}

	}

	/**
	 * inOrder lazy iterator class
	 */
	public class iterator implements Iterator<T> {
		Stack<BinaryNode> nodes;

		public iterator() {
			nodes = toStackInOrder();
		}

		@Override
		public boolean hasNext() {
			return !this.nodes.isEmpty();
		}

		@Override
		public T next() {
			if (!hasNext()) {
				throw new NoSuchElementException("No more next");
			}
			return this.nodes.pop().data;
		}

		public Stack<BinaryNode> toStackInOrder() {
			Stack<BinaryNode> nodes = new Stack<BinaryNode>();
			return nodes;
		}
	}

	// ============ BOOLEAN CONTAINER CLASS ============ //
	protected class BooleanContainer {
		boolean insertSuccessful;
		BinaryNode node;

		public BooleanContainer() {
			this.node = NULL_NODE;
			this.insertSuccessful = false;
		}

		public BooleanContainer(BinaryNode node) {
			this.node = node;
			this.insertSuccessful = false;
		}

		public void setBoolean(boolean b) {
			this.insertSuccessful = b;
		}

		public boolean getBoolean() {
			return this.insertSuccessful;
		}

		public void setNode(BinaryNode n) {
			this.node = n;
		}

		public BinaryNode getNode() {
			return this.node;
		}

	}
}
